// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: did/did_v1/did.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Meproto_Did_V1_Algorithm: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case algUnspecified // = 0

  /// EdDSA over Curve25519
  case ed25519 // = 1

  /// X25519 key agreement (was missing before)
  case x25519 // = 2

  /// P-256 / secp256r1
  case es256 // = 3

  /// Bitcoin/Ethereum curve
  case secp256K1 // = 4

  /// Dilithium-level signature
  case mlDsa87 // = 5

  /// Kyber KEM 1024
  case mlKem1024 // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .algUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .algUnspecified
    case 1: self = .ed25519
    case 2: self = .x25519
    case 3: self = .es256
    case 4: self = .secp256K1
    case 5: self = .mlDsa87
    case 6: self = .mlKem1024
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .algUnspecified: return 0
    case .ed25519: return 1
    case .x25519: return 2
    case .es256: return 3
    case .secp256K1: return 4
    case .mlDsa87: return 5
    case .mlKem1024: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Meproto_Did_V1_Algorithm] = [
    .algUnspecified,
    .ed25519,
    .x25519,
    .es256,
    .secp256K1,
    .mlDsa87,
    .mlKem1024,
  ]

}

public enum Meproto_Did_V1_UserVerificationMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case uvmUnspecified // = 0
  case none // = 1
  case pin // = 2
  case passcode // = 3
  case password // = 4
  case fingerprint // = 5
  case face // = 6
  case iris // = 7
  case voice // = 8
  case pattern // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .uvmUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .uvmUnspecified
    case 1: self = .none
    case 2: self = .pin
    case 3: self = .passcode
    case 4: self = .password
    case 5: self = .fingerprint
    case 6: self = .face
    case 7: self = .iris
    case 8: self = .voice
    case 9: self = .pattern
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .uvmUnspecified: return 0
    case .none: return 1
    case .pin: return 2
    case .passcode: return 3
    case .password: return 4
    case .fingerprint: return 5
    case .face: return 6
    case .iris: return 7
    case .voice: return 8
    case .pattern: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Meproto_Did_V1_UserVerificationMethod] = [
    .uvmUnspecified,
    .none,
    .pin,
    .passcode,
    .password,
    .fingerprint,
    .face,
    .iris,
    .voice,
    .pattern,
  ]

}

public enum Meproto_Did_V1_VerificationMethodType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case vmtUnspecified // = 0
  case multikey // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .vmtUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .vmtUnspecified
    case 1: self = .multikey
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .vmtUnspecified: return 0
    case .multikey: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Meproto_Did_V1_VerificationMethodType] = [
    .vmtUnspecified,
    .multikey,
  ]

}

public enum Meproto_Did_V1_DomainVerificationMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case dvmUnspecified // = 0
  case dnsTxt // = 1
  case httpsWellKnown // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .dvmUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .dvmUnspecified
    case 1: self = .dnsTxt
    case 2: self = .httpsWellKnown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .dvmUnspecified: return 0
    case .dnsTxt: return 1
    case .httpsWellKnown: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Meproto_Did_V1_DomainVerificationMethod] = [
    .dvmUnspecified,
    .dnsTxt,
    .httpsWellKnown,
  ]

}

public struct Meproto_Did_V1_VMKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var controller: String = String()

  /// always MULTIKEY for now
  public var type: Meproto_Did_V1_VerificationMethodType = .vmtUnspecified

  /// optional but helpful for fast routing
  public var alg: Meproto_Did_V1_Algorithm = .algUnspecified

  /// multikey-encoded public key
  public var pk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_Service: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: String = String()

  public var version: String = String()

  /// JSON blob
  public var serviceData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_Attestation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alg: Meproto_Did_V1_Algorithm = .algUnspecified

  public var verificationMethod: String = String()

  public var sig: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_Proof: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: String = String()

  public var cryptosuite: String = String()

  public var purpose: String = String()

  public var vm: String = String()

  public var created: String = String()

  public var jws: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_DomainVerification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var method: Meproto_Did_V1_DomainVerificationMethod = .dvmUnspecified

  public var domain: String = String()

  public var binding: Meproto_Did_V1_DomainVerification.OneOf_Binding? = nil

  public var dns: Meproto_Did_V1_DNSBinding {
    get {
      if case .dns(let v)? = binding {return v}
      return Meproto_Did_V1_DNSBinding()
    }
    set {binding = .dns(newValue)}
  }

  public var wellknown: Meproto_Did_V1_WellKnownBinding {
    get {
      if case .wellknown(let v)? = binding {return v}
      return Meproto_Did_V1_WellKnownBinding()
    }
    set {binding = .wellknown(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Binding: Equatable, Sendable {
    case dns(Meproto_Did_V1_DNSBinding)
    case wellknown(Meproto_Did_V1_WellKnownBinding)

  }

  public init() {}
}

public struct Meproto_Did_V1_DNSBinding: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// default: "_did"
  public var recordName: String = String()

  /// TXT record value
  public var txtValue: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_WellKnownBinding: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// default: "/.well-known/did-configuration.json"
  public var uri: String = String()

  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_UpdatePolicy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var allowed: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_DIDDocument: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Core identity
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var controller: String {
    get {return _storage._controller}
    set {_uniqueStorage()._controller = newValue}
  }

  /// @context
  public var ctx: [String] {
    get {return _storage._ctx}
    set {_uniqueStorage()._ctx = newValue}
  }

  /// Metadata
  public var alsoKnownAs: [String] {
    get {return _storage._alsoKnownAs}
    set {_uniqueStorage()._alsoKnownAs = newValue}
  }

  public var biometric: Bool {
    get {return _storage._biometric}
    set {_uniqueStorage()._biometric = newValue}
  }

  public var hardware: Bool {
    get {return _storage._hardware}
    set {_uniqueStorage()._hardware = newValue}
  }

  public var deviceModel: String {
    get {return _storage._deviceModel}
    set {_uniqueStorage()._deviceModel = newValue}
  }

  public var userVerificationMethod: Meproto_Did_V1_UserVerificationMethod {
    get {return _storage._userVerificationMethod}
    set {_uniqueStorage()._userVerificationMethod = newValue}
  }

  /// Core state
  public var seq: UInt64 {
    get {return _storage._seq}
    set {_uniqueStorage()._seq = newValue}
  }

  public var prev: String {
    get {return _storage._prev}
    set {_uniqueStorage()._prev = newValue}
  }

  public var core: String {
    get {return _storage._core}
    set {_uniqueStorage()._core = newValue}
  }

  public var coreCbor: Data {
    get {return _storage._coreCbor}
    set {_uniqueStorage()._coreCbor = newValue}
  }

  public var keyHistory: [String] {
    get {return _storage._keyHistory}
    set {_uniqueStorage()._keyHistory = newValue}
  }

  /// Verification relationships
  public var vm: [Meproto_Did_V1_VMKey] {
    get {return _storage._vm}
    set {_uniqueStorage()._vm = newValue}
  }

  public var authentication: [String] {
    get {return _storage._authentication}
    set {_uniqueStorage()._authentication = newValue}
  }

  public var assertion: [String] {
    get {return _storage._assertion}
    set {_uniqueStorage()._assertion = newValue}
  }

  public var invocation: [String] {
    get {return _storage._invocation}
    set {_uniqueStorage()._invocation = newValue}
  }

  public var keyAgreement: [String] {
    get {return _storage._keyAgreement}
    set {_uniqueStorage()._keyAgreement = newValue}
  }

  /// Services
  public var svc: [Meproto_Did_V1_Service] {
    get {return _storage._svc}
    set {_uniqueStorage()._svc = newValue}
  }

  /// Policy & attestations
  public var policy: Meproto_Did_V1_UpdatePolicy {
    get {return _storage._policy ?? Meproto_Did_V1_UpdatePolicy()}
    set {_uniqueStorage()._policy = newValue}
  }
  /// Returns true if `policy` has been explicitly set.
  public var hasPolicy: Bool {return _storage._policy != nil}
  /// Clears the value of `policy`. Subsequent reads from it will return its default value.
  public mutating func clearPolicy() {_uniqueStorage()._policy = nil}

  public var att: [Meproto_Did_V1_Attestation] {
    get {return _storage._att}
    set {_uniqueStorage()._att = newValue}
  }

  /// Optional P-256 DataIntegrityProof
  public var proof: Meproto_Did_V1_Proof {
    get {return _storage._proof ?? Meproto_Did_V1_Proof()}
    set {_uniqueStorage()._proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  public var hasProof: Bool {return _storage._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  public mutating func clearProof() {_uniqueStorage()._proof = nil}

  /// Domain verification objects
  public var dv: [Meproto_Did_V1_DomainVerification] {
    get {return _storage._dv}
    set {_uniqueStorage()._dv = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "meproto.did.v1"

extension Meproto_Did_V1_Algorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ALG_UNSPECIFIED\0\u{1}ED25519\0\u{1}X25519\0\u{1}ES256\0\u{1}SECP256K1\0\u{1}ML_DSA_87\0\u{1}ML_KEM_1024\0")
}

extension Meproto_Did_V1_UserVerificationMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UVM_UNSPECIFIED\0\u{1}NONE\0\u{1}PIN\0\u{1}PASSCODE\0\u{1}PASSWORD\0\u{1}FINGERPRINT\0\u{1}FACE\0\u{1}IRIS\0\u{1}VOICE\0\u{1}PATTERN\0")
}

extension Meproto_Did_V1_VerificationMethodType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0VMT_UNSPECIFIED\0\u{1}MULTIKEY\0")
}

extension Meproto_Did_V1_DomainVerificationMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DVM_UNSPECIFIED\0\u{1}DNS_TXT\0\u{1}HTTPS_WELL_KNOWN\0")
}

extension Meproto_Did_V1_VMKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VMKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}controller\0\u{1}type\0\u{1}alg\0\u{1}pk\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.controller) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.alg) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.pk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.controller.isEmpty {
      try visitor.visitSingularStringField(value: self.controller, fieldNumber: 2)
    }
    if self.type != .vmtUnspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.alg != .algUnspecified {
      try visitor.visitSingularEnumField(value: self.alg, fieldNumber: 4)
    }
    if !self.pk.isEmpty {
      try visitor.visitSingularBytesField(value: self.pk, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_VMKey, rhs: Meproto_Did_V1_VMKey) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.controller != rhs.controller {return false}
    if lhs.type != rhs.type {return false}
    if lhs.alg != rhs.alg {return false}
    if lhs.pk != rhs.pk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_Service: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Service"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}type\0\u{1}version\0\u{3}service_data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.serviceData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if !self.serviceData.isEmpty {
      try visitor.visitSingularBytesField(value: self.serviceData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_Service, rhs: Meproto_Did_V1_Service) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.version != rhs.version {return false}
    if lhs.serviceData != rhs.serviceData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_Attestation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Attestation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}alg\0\u{3}verification_method\0\u{1}sig\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.alg) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.verificationMethod) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.sig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alg != .algUnspecified {
      try visitor.visitSingularEnumField(value: self.alg, fieldNumber: 1)
    }
    if !self.verificationMethod.isEmpty {
      try visitor.visitSingularStringField(value: self.verificationMethod, fieldNumber: 2)
    }
    if !self.sig.isEmpty {
      try visitor.visitSingularBytesField(value: self.sig, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_Attestation, rhs: Meproto_Did_V1_Attestation) -> Bool {
    if lhs.alg != rhs.alg {return false}
    if lhs.verificationMethod != rhs.verificationMethod {return false}
    if lhs.sig != rhs.sig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_Proof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Proof"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}type\0\u{1}cryptosuite\0\u{1}purpose\0\u{1}vm\0\u{1}created\0\u{1}jws\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cryptosuite) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.purpose) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.vm) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.created) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.jws) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.cryptosuite.isEmpty {
      try visitor.visitSingularStringField(value: self.cryptosuite, fieldNumber: 3)
    }
    if !self.purpose.isEmpty {
      try visitor.visitSingularStringField(value: self.purpose, fieldNumber: 4)
    }
    if !self.vm.isEmpty {
      try visitor.visitSingularStringField(value: self.vm, fieldNumber: 5)
    }
    if !self.created.isEmpty {
      try visitor.visitSingularStringField(value: self.created, fieldNumber: 6)
    }
    if !self.jws.isEmpty {
      try visitor.visitSingularStringField(value: self.jws, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_Proof, rhs: Meproto_Did_V1_Proof) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.cryptosuite != rhs.cryptosuite {return false}
    if lhs.purpose != rhs.purpose {return false}
    if lhs.vm != rhs.vm {return false}
    if lhs.created != rhs.created {return false}
    if lhs.jws != rhs.jws {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_DomainVerification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DomainVerification"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}method\0\u{1}domain\0\u{1}dns\0\u{1}wellknown\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 3: try {
        var v: Meproto_Did_V1_DNSBinding?
        var hadOneofValue = false
        if let current = self.binding {
          hadOneofValue = true
          if case .dns(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.binding = .dns(v)
        }
      }()
      case 4: try {
        var v: Meproto_Did_V1_WellKnownBinding?
        var hadOneofValue = false
        if let current = self.binding {
          hadOneofValue = true
          if case .wellknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.binding = .wellknown(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.method != .dvmUnspecified {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 1)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 2)
    }
    switch self.binding {
    case .dns?: try {
      guard case .dns(let v)? = self.binding else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .wellknown?: try {
      guard case .wellknown(let v)? = self.binding else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_DomainVerification, rhs: Meproto_Did_V1_DomainVerification) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.binding != rhs.binding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_DNSBinding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DNSBinding"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}record_name\0\u{3}txt_value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.txtValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recordName.isEmpty {
      try visitor.visitSingularStringField(value: self.recordName, fieldNumber: 1)
    }
    if !self.txtValue.isEmpty {
      try visitor.visitSingularStringField(value: self.txtValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_DNSBinding, rhs: Meproto_Did_V1_DNSBinding) -> Bool {
    if lhs.recordName != rhs.recordName {return false}
    if lhs.txtValue != rhs.txtValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_WellKnownBinding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WellKnownBinding"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uri\0\u{1}content\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_WellKnownBinding, rhs: Meproto_Did_V1_WellKnownBinding) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_UpdatePolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePolicy"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}allowed\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowed.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_UpdatePolicy, rhs: Meproto_Did_V1_UpdatePolicy) -> Bool {
    if lhs.allowed != rhs.allowed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_DIDDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DIDDocument"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}controller\0\u{1}ctx\0\u{3}also_known_as\0\u{1}biometric\0\u{1}hardware\0\u{3}device_model\0\u{3}user_verification_method\0\u{1}seq\0\u{1}prev\0\u{1}core\0\u{3}core_cbor\0\u{3}key_history\0\u{1}vm\0\u{1}authentication\0\u{1}assertion\0\u{1}invocation\0\u{3}key_agreement\0\u{1}svc\0\u{1}policy\0\u{1}att\0\u{1}proof\0\u{1}dv\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _controller: String = String()
    var _ctx: [String] = []
    var _alsoKnownAs: [String] = []
    var _biometric: Bool = false
    var _hardware: Bool = false
    var _deviceModel: String = String()
    var _userVerificationMethod: Meproto_Did_V1_UserVerificationMethod = .uvmUnspecified
    var _seq: UInt64 = 0
    var _prev: String = String()
    var _core: String = String()
    var _coreCbor: Data = Data()
    var _keyHistory: [String] = []
    var _vm: [Meproto_Did_V1_VMKey] = []
    var _authentication: [String] = []
    var _assertion: [String] = []
    var _invocation: [String] = []
    var _keyAgreement: [String] = []
    var _svc: [Meproto_Did_V1_Service] = []
    var _policy: Meproto_Did_V1_UpdatePolicy? = nil
    var _att: [Meproto_Did_V1_Attestation] = []
    var _proof: Meproto_Did_V1_Proof? = nil
    var _dv: [Meproto_Did_V1_DomainVerification] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _controller = source._controller
      _ctx = source._ctx
      _alsoKnownAs = source._alsoKnownAs
      _biometric = source._biometric
      _hardware = source._hardware
      _deviceModel = source._deviceModel
      _userVerificationMethod = source._userVerificationMethod
      _seq = source._seq
      _prev = source._prev
      _core = source._core
      _coreCbor = source._coreCbor
      _keyHistory = source._keyHistory
      _vm = source._vm
      _authentication = source._authentication
      _assertion = source._assertion
      _invocation = source._invocation
      _keyAgreement = source._keyAgreement
      _svc = source._svc
      _policy = source._policy
      _att = source._att
      _proof = source._proof
      _dv = source._dv
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._controller) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._ctx) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._alsoKnownAs) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._biometric) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._hardware) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._deviceModel) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._userVerificationMethod) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._seq) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._prev) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._core) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._coreCbor) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._keyHistory) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._vm) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._authentication) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._assertion) }()
        case 17: try { try decoder.decodeRepeatedStringField(value: &_storage._invocation) }()
        case 18: try { try decoder.decodeRepeatedStringField(value: &_storage._keyAgreement) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._svc) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._policy) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._att) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._proof) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._dv) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._controller.isEmpty {
        try visitor.visitSingularStringField(value: _storage._controller, fieldNumber: 2)
      }
      if !_storage._ctx.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._ctx, fieldNumber: 3)
      }
      if !_storage._alsoKnownAs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._alsoKnownAs, fieldNumber: 4)
      }
      if _storage._biometric != false {
        try visitor.visitSingularBoolField(value: _storage._biometric, fieldNumber: 5)
      }
      if _storage._hardware != false {
        try visitor.visitSingularBoolField(value: _storage._hardware, fieldNumber: 6)
      }
      if !_storage._deviceModel.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deviceModel, fieldNumber: 7)
      }
      if _storage._userVerificationMethod != .uvmUnspecified {
        try visitor.visitSingularEnumField(value: _storage._userVerificationMethod, fieldNumber: 8)
      }
      if _storage._seq != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._seq, fieldNumber: 9)
      }
      if !_storage._prev.isEmpty {
        try visitor.visitSingularStringField(value: _storage._prev, fieldNumber: 10)
      }
      if !_storage._core.isEmpty {
        try visitor.visitSingularStringField(value: _storage._core, fieldNumber: 11)
      }
      if !_storage._coreCbor.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._coreCbor, fieldNumber: 12)
      }
      if !_storage._keyHistory.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._keyHistory, fieldNumber: 13)
      }
      if !_storage._vm.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._vm, fieldNumber: 14)
      }
      if !_storage._authentication.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._authentication, fieldNumber: 15)
      }
      if !_storage._assertion.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._assertion, fieldNumber: 16)
      }
      if !_storage._invocation.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._invocation, fieldNumber: 17)
      }
      if !_storage._keyAgreement.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._keyAgreement, fieldNumber: 18)
      }
      if !_storage._svc.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._svc, fieldNumber: 19)
      }
      try { if let v = _storage._policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._att.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._att, fieldNumber: 21)
      }
      try { if let v = _storage._proof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._dv.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dv, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_DIDDocument, rhs: Meproto_Did_V1_DIDDocument) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._controller != rhs_storage._controller {return false}
        if _storage._ctx != rhs_storage._ctx {return false}
        if _storage._alsoKnownAs != rhs_storage._alsoKnownAs {return false}
        if _storage._biometric != rhs_storage._biometric {return false}
        if _storage._hardware != rhs_storage._hardware {return false}
        if _storage._deviceModel != rhs_storage._deviceModel {return false}
        if _storage._userVerificationMethod != rhs_storage._userVerificationMethod {return false}
        if _storage._seq != rhs_storage._seq {return false}
        if _storage._prev != rhs_storage._prev {return false}
        if _storage._core != rhs_storage._core {return false}
        if _storage._coreCbor != rhs_storage._coreCbor {return false}
        if _storage._keyHistory != rhs_storage._keyHistory {return false}
        if _storage._vm != rhs_storage._vm {return false}
        if _storage._authentication != rhs_storage._authentication {return false}
        if _storage._assertion != rhs_storage._assertion {return false}
        if _storage._invocation != rhs_storage._invocation {return false}
        if _storage._keyAgreement != rhs_storage._keyAgreement {return false}
        if _storage._svc != rhs_storage._svc {return false}
        if _storage._policy != rhs_storage._policy {return false}
        if _storage._att != rhs_storage._att {return false}
        if _storage._proof != rhs_storage._proof {return false}
        if _storage._dv != rhs_storage._dv {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
