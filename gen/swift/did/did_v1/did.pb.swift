// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: did/did_v1/did.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Meproto_Did_V1_Algorithm: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case algUnspecified // = 0

  /// EdDSA over Curve25519
  case ed25519 // = 1

  /// X25519 key agreement (was missing before)
  case x25519 // = 2

  /// P-256 / secp256r1
  case es256 // = 3

  /// Bitcoin/Ethereum curve
  case secp256K1 // = 4

  /// Dilithium-level signature
  case mlDsa87 // = 5

  /// Kyber KEM 1024
  case mlKem1024 // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .algUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .algUnspecified
    case 1: self = .ed25519
    case 2: self = .x25519
    case 3: self = .es256
    case 4: self = .secp256K1
    case 5: self = .mlDsa87
    case 6: self = .mlKem1024
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .algUnspecified: return 0
    case .ed25519: return 1
    case .x25519: return 2
    case .es256: return 3
    case .secp256K1: return 4
    case .mlDsa87: return 5
    case .mlKem1024: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Meproto_Did_V1_Algorithm] = [
    .algUnspecified,
    .ed25519,
    .x25519,
    .es256,
    .secp256K1,
    .mlDsa87,
    .mlKem1024,
  ]

}

public enum Meproto_Did_V1_UserVerificationMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case uvmUnspecified // = 0
  case none // = 1
  case pin // = 2
  case passcode // = 3
  case password // = 4
  case fingerprint // = 5
  case face // = 6
  case iris // = 7
  case voice // = 8
  case pattern // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .uvmUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .uvmUnspecified
    case 1: self = .none
    case 2: self = .pin
    case 3: self = .passcode
    case 4: self = .password
    case 5: self = .fingerprint
    case 6: self = .face
    case 7: self = .iris
    case 8: self = .voice
    case 9: self = .pattern
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .uvmUnspecified: return 0
    case .none: return 1
    case .pin: return 2
    case .passcode: return 3
    case .password: return 4
    case .fingerprint: return 5
    case .face: return 6
    case .iris: return 7
    case .voice: return 8
    case .pattern: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Meproto_Did_V1_UserVerificationMethod] = [
    .uvmUnspecified,
    .none,
    .pin,
    .passcode,
    .password,
    .fingerprint,
    .face,
    .iris,
    .voice,
    .pattern,
  ]

}

public enum Meproto_Did_V1_DomainVerificationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case dvtUnspecified // = 0
  case dnsTxt // = 1
  case httpsWellKnown // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .dvtUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .dvtUnspecified
    case 1: self = .dnsTxt
    case 2: self = .httpsWellKnown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .dvtUnspecified: return 0
    case .dnsTxt: return 1
    case .httpsWellKnown: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Meproto_Did_V1_DomainVerificationType] = [
    .dvtUnspecified,
    .dnsTxt,
    .httpsWellKnown,
  ]

}

public struct Meproto_Did_V1_VMKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var controller: String = String()

  public var alg: Meproto_Did_V1_Algorithm = .algUnspecified

  public var pk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_Service: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: String = String()

  public var version: String = String()

  /// JSON blob
  public var endpoint: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_Attestation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alg: Meproto_Did_V1_Algorithm = .algUnspecified

  public var vm: String = String()

  public var sig: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_Proof: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: String = String()

  public var cryptosuite: String = String()

  public var purpose: String = String()

  public var vm: String = String()

  public var created: String = String()

  public var jws: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_DomainVerification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var t: Meproto_Did_V1_DomainVerificationType = .dvtUnspecified

  public var domain: String = String()

  public var method: String = String()

  public var binding: Data = Data()

  public var bindingURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_UpdatePolicy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var allowed: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Meproto_Did_V1_DIDDocument: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Core identity
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var controller: String {
    get {return _storage._controller}
    set {_uniqueStorage()._controller = newValue}
  }

  /// @context
  public var ctx: [String] {
    get {return _storage._ctx}
    set {_uniqueStorage()._ctx = newValue}
  }

  /// Metadata
  public var also: [String] {
    get {return _storage._also}
    set {_uniqueStorage()._also = newValue}
  }

  public var biometric: Bool {
    get {return _storage._biometric}
    set {_uniqueStorage()._biometric = newValue}
  }

  public var hardware: Bool {
    get {return _storage._hardware}
    set {_uniqueStorage()._hardware = newValue}
  }

  public var deviceModel: String {
    get {return _storage._deviceModel}
    set {_uniqueStorage()._deviceModel = newValue}
  }

  public var userVerificationMethod: Meproto_Did_V1_UserVerificationMethod {
    get {return _storage._userVerificationMethod}
    set {_uniqueStorage()._userVerificationMethod = newValue}
  }

  /// Core state
  public var seq: UInt64 {
    get {return _storage._seq}
    set {_uniqueStorage()._seq = newValue}
  }

  public var prev: String {
    get {return _storage._prev}
    set {_uniqueStorage()._prev = newValue}
  }

  public var core: String {
    get {return _storage._core}
    set {_uniqueStorage()._core = newValue}
  }

  public var coreCbor: Data {
    get {return _storage._coreCbor}
    set {_uniqueStorage()._coreCbor = newValue}
  }

  public var keyHistory: [String] {
    get {return _storage._keyHistory}
    set {_uniqueStorage()._keyHistory = newValue}
  }

  /// Verification relationships
  public var vm: [Meproto_Did_V1_VMKey] {
    get {return _storage._vm}
    set {_uniqueStorage()._vm = newValue}
  }

  public var authn: [String] {
    get {return _storage._authn}
    set {_uniqueStorage()._authn = newValue}
  }

  public var assert: [String] {
    get {return _storage._assert}
    set {_uniqueStorage()._assert = newValue}
  }

  public var inv: [String] {
    get {return _storage._inv}
    set {_uniqueStorage()._inv = newValue}
  }

  public var ka: [String] {
    get {return _storage._ka}
    set {_uniqueStorage()._ka = newValue}
  }

  /// Services
  public var svc: [Meproto_Did_V1_Service] {
    get {return _storage._svc}
    set {_uniqueStorage()._svc = newValue}
  }

  /// Policy & attestations
  public var policy: Meproto_Did_V1_UpdatePolicy {
    get {return _storage._policy ?? Meproto_Did_V1_UpdatePolicy()}
    set {_uniqueStorage()._policy = newValue}
  }
  /// Returns true if `policy` has been explicitly set.
  public var hasPolicy: Bool {return _storage._policy != nil}
  /// Clears the value of `policy`. Subsequent reads from it will return its default value.
  public mutating func clearPolicy() {_uniqueStorage()._policy = nil}

  public var att: [Meproto_Did_V1_Attestation] {
    get {return _storage._att}
    set {_uniqueStorage()._att = newValue}
  }

  /// Optional P-256 DataIntegrityProof
  public var proof: Meproto_Did_V1_Proof {
    get {return _storage._proof ?? Meproto_Did_V1_Proof()}
    set {_uniqueStorage()._proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  public var hasProof: Bool {return _storage._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  public mutating func clearProof() {_uniqueStorage()._proof = nil}

  /// Domain verification objects
  public var dv: [Meproto_Did_V1_DomainVerification] {
    get {return _storage._dv}
    set {_uniqueStorage()._dv = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "meproto.did.v1"

extension Meproto_Did_V1_Algorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ALG_UNSPECIFIED\0\u{1}ED25519\0\u{1}X25519\0\u{1}ES256\0\u{1}SECP256K1\0\u{1}ML_DSA_87\0\u{1}ML_KEM_1024\0")
}

extension Meproto_Did_V1_UserVerificationMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UVM_UNSPECIFIED\0\u{1}NONE\0\u{1}PIN\0\u{1}PASSCODE\0\u{1}PASSWORD\0\u{1}FINGERPRINT\0\u{1}FACE\0\u{1}IRIS\0\u{1}VOICE\0\u{1}PATTERN\0")
}

extension Meproto_Did_V1_DomainVerificationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DVT_UNSPECIFIED\0\u{1}DNS_TXT\0\u{1}HTTPS_WELL_KNOWN\0")
}

extension Meproto_Did_V1_VMKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VMKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}controller\0\u{1}alg\0\u{1}pk\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.controller) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.alg) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.pk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.controller.isEmpty {
      try visitor.visitSingularStringField(value: self.controller, fieldNumber: 2)
    }
    if self.alg != .algUnspecified {
      try visitor.visitSingularEnumField(value: self.alg, fieldNumber: 3)
    }
    if !self.pk.isEmpty {
      try visitor.visitSingularBytesField(value: self.pk, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_VMKey, rhs: Meproto_Did_V1_VMKey) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.controller != rhs.controller {return false}
    if lhs.alg != rhs.alg {return false}
    if lhs.pk != rhs.pk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_Service: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Service"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}type\0\u{1}version\0\u{1}endpoint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.endpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularBytesField(value: self.endpoint, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_Service, rhs: Meproto_Did_V1_Service) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.version != rhs.version {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_Attestation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Attestation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}alg\0\u{1}vm\0\u{1}sig\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.alg) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.vm) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.sig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alg != .algUnspecified {
      try visitor.visitSingularEnumField(value: self.alg, fieldNumber: 1)
    }
    if !self.vm.isEmpty {
      try visitor.visitSingularStringField(value: self.vm, fieldNumber: 2)
    }
    if !self.sig.isEmpty {
      try visitor.visitSingularBytesField(value: self.sig, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_Attestation, rhs: Meproto_Did_V1_Attestation) -> Bool {
    if lhs.alg != rhs.alg {return false}
    if lhs.vm != rhs.vm {return false}
    if lhs.sig != rhs.sig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_Proof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Proof"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}type\0\u{1}cryptosuite\0\u{1}purpose\0\u{1}vm\0\u{1}created\0\u{1}jws\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cryptosuite) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.purpose) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.vm) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.created) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.jws) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.cryptosuite.isEmpty {
      try visitor.visitSingularStringField(value: self.cryptosuite, fieldNumber: 3)
    }
    if !self.purpose.isEmpty {
      try visitor.visitSingularStringField(value: self.purpose, fieldNumber: 4)
    }
    if !self.vm.isEmpty {
      try visitor.visitSingularStringField(value: self.vm, fieldNumber: 5)
    }
    if !self.created.isEmpty {
      try visitor.visitSingularStringField(value: self.created, fieldNumber: 6)
    }
    if !self.jws.isEmpty {
      try visitor.visitSingularStringField(value: self.jws, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_Proof, rhs: Meproto_Did_V1_Proof) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.cryptosuite != rhs.cryptosuite {return false}
    if lhs.purpose != rhs.purpose {return false}
    if lhs.vm != rhs.vm {return false}
    if lhs.created != rhs.created {return false}
    if lhs.jws != rhs.jws {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_DomainVerification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DomainVerification"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}t\0\u{1}domain\0\u{1}method\0\u{1}binding\0\u{3}binding_url\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.t) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.method) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.binding) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.bindingURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.t != .dvtUnspecified {
      try visitor.visitSingularEnumField(value: self.t, fieldNumber: 1)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 2)
    }
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 3)
    }
    if !self.binding.isEmpty {
      try visitor.visitSingularBytesField(value: self.binding, fieldNumber: 4)
    }
    if !self.bindingURL.isEmpty {
      try visitor.visitSingularStringField(value: self.bindingURL, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_DomainVerification, rhs: Meproto_Did_V1_DomainVerification) -> Bool {
    if lhs.t != rhs.t {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.method != rhs.method {return false}
    if lhs.binding != rhs.binding {return false}
    if lhs.bindingURL != rhs.bindingURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_UpdatePolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePolicy"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}allowed\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowed.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_UpdatePolicy, rhs: Meproto_Did_V1_UpdatePolicy) -> Bool {
    if lhs.allowed != rhs.allowed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meproto_Did_V1_DIDDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DIDDocument"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}controller\0\u{1}ctx\0\u{1}also\0\u{1}biometric\0\u{1}hardware\0\u{3}device_model\0\u{3}user_verification_method\0\u{1}seq\0\u{1}prev\0\u{1}core\0\u{3}core_cbor\0\u{3}key_history\0\u{1}vm\0\u{1}authn\0\u{1}assert\0\u{1}inv\0\u{1}ka\0\u{1}svc\0\u{1}policy\0\u{1}att\0\u{1}proof\0\u{1}dv\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _controller: String = String()
    var _ctx: [String] = []
    var _also: [String] = []
    var _biometric: Bool = false
    var _hardware: Bool = false
    var _deviceModel: String = String()
    var _userVerificationMethod: Meproto_Did_V1_UserVerificationMethod = .uvmUnspecified
    var _seq: UInt64 = 0
    var _prev: String = String()
    var _core: String = String()
    var _coreCbor: Data = Data()
    var _keyHistory: [String] = []
    var _vm: [Meproto_Did_V1_VMKey] = []
    var _authn: [String] = []
    var _assert: [String] = []
    var _inv: [String] = []
    var _ka: [String] = []
    var _svc: [Meproto_Did_V1_Service] = []
    var _policy: Meproto_Did_V1_UpdatePolicy? = nil
    var _att: [Meproto_Did_V1_Attestation] = []
    var _proof: Meproto_Did_V1_Proof? = nil
    var _dv: [Meproto_Did_V1_DomainVerification] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _controller = source._controller
      _ctx = source._ctx
      _also = source._also
      _biometric = source._biometric
      _hardware = source._hardware
      _deviceModel = source._deviceModel
      _userVerificationMethod = source._userVerificationMethod
      _seq = source._seq
      _prev = source._prev
      _core = source._core
      _coreCbor = source._coreCbor
      _keyHistory = source._keyHistory
      _vm = source._vm
      _authn = source._authn
      _assert = source._assert
      _inv = source._inv
      _ka = source._ka
      _svc = source._svc
      _policy = source._policy
      _att = source._att
      _proof = source._proof
      _dv = source._dv
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._controller) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._ctx) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._also) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._biometric) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._hardware) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._deviceModel) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._userVerificationMethod) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._seq) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._prev) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._core) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._coreCbor) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._keyHistory) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._vm) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._authn) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._assert) }()
        case 17: try { try decoder.decodeRepeatedStringField(value: &_storage._inv) }()
        case 18: try { try decoder.decodeRepeatedStringField(value: &_storage._ka) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._svc) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._policy) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._att) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._proof) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._dv) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._controller.isEmpty {
        try visitor.visitSingularStringField(value: _storage._controller, fieldNumber: 2)
      }
      if !_storage._ctx.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._ctx, fieldNumber: 3)
      }
      if !_storage._also.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._also, fieldNumber: 4)
      }
      if _storage._biometric != false {
        try visitor.visitSingularBoolField(value: _storage._biometric, fieldNumber: 5)
      }
      if _storage._hardware != false {
        try visitor.visitSingularBoolField(value: _storage._hardware, fieldNumber: 6)
      }
      if !_storage._deviceModel.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deviceModel, fieldNumber: 7)
      }
      if _storage._userVerificationMethod != .uvmUnspecified {
        try visitor.visitSingularEnumField(value: _storage._userVerificationMethod, fieldNumber: 8)
      }
      if _storage._seq != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._seq, fieldNumber: 9)
      }
      if !_storage._prev.isEmpty {
        try visitor.visitSingularStringField(value: _storage._prev, fieldNumber: 10)
      }
      if !_storage._core.isEmpty {
        try visitor.visitSingularStringField(value: _storage._core, fieldNumber: 11)
      }
      if !_storage._coreCbor.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._coreCbor, fieldNumber: 12)
      }
      if !_storage._keyHistory.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._keyHistory, fieldNumber: 13)
      }
      if !_storage._vm.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._vm, fieldNumber: 14)
      }
      if !_storage._authn.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._authn, fieldNumber: 15)
      }
      if !_storage._assert.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._assert, fieldNumber: 16)
      }
      if !_storage._inv.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._inv, fieldNumber: 17)
      }
      if !_storage._ka.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._ka, fieldNumber: 18)
      }
      if !_storage._svc.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._svc, fieldNumber: 19)
      }
      try { if let v = _storage._policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._att.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._att, fieldNumber: 21)
      }
      try { if let v = _storage._proof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._dv.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dv, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Meproto_Did_V1_DIDDocument, rhs: Meproto_Did_V1_DIDDocument) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._controller != rhs_storage._controller {return false}
        if _storage._ctx != rhs_storage._ctx {return false}
        if _storage._also != rhs_storage._also {return false}
        if _storage._biometric != rhs_storage._biometric {return false}
        if _storage._hardware != rhs_storage._hardware {return false}
        if _storage._deviceModel != rhs_storage._deviceModel {return false}
        if _storage._userVerificationMethod != rhs_storage._userVerificationMethod {return false}
        if _storage._seq != rhs_storage._seq {return false}
        if _storage._prev != rhs_storage._prev {return false}
        if _storage._core != rhs_storage._core {return false}
        if _storage._coreCbor != rhs_storage._coreCbor {return false}
        if _storage._keyHistory != rhs_storage._keyHistory {return false}
        if _storage._vm != rhs_storage._vm {return false}
        if _storage._authn != rhs_storage._authn {return false}
        if _storage._assert != rhs_storage._assert {return false}
        if _storage._inv != rhs_storage._inv {return false}
        if _storage._ka != rhs_storage._ka {return false}
        if _storage._svc != rhs_storage._svc {return false}
        if _storage._policy != rhs_storage._policy {return false}
        if _storage._att != rhs_storage._att {return false}
        if _storage._proof != rhs_storage._proof {return false}
        if _storage._dv != rhs_storage._dv {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
